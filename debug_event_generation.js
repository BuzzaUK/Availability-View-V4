const { Sequelize } = require('sequelize');
const path = require('path');

// Database configuration
const sequelize = new Sequelize({
  dialect: 'sqlite',
  storage: path.join(__dirname, 'database.sqlite'),
  logging: false
});

async function debugEventGeneration() {
  try {
    console.log('🔍 Debugging Event Generation System...');
    
    // Check assets
    const [assets] = await sequelize.query(`
      SELECT 
        id,
        name,
        type,
        pin_number,
        logger_id,
        current_state,
        last_state_change,
        created_at
      FROM assets
      ORDER BY created_at DESC
    `);
    
    console.log(`\n📊 Found ${assets.length} assets:`);
    assets.forEach((asset, index) => {
      const lastChange = asset.last_state_change ? new Date(asset.last_state_change).toLocaleString() : 'Never';
      console.log(`  ${index + 1}. ${asset.name} (ID: ${asset.id})`);
      console.log(`     Type: ${asset.type || 'Not specified'}`);
      console.log(`     Logger ID: ${asset.logger_id || 'Not assigned'}`);
      console.log(`     Pin: ${asset.pin_number}`);
      console.log(`     Current State: ${asset.current_state || 'Unknown'}`);
      console.log(`     Last State Change: ${lastChange}`);
      console.log('');
    });
    
    // Check loggers
    const [loggers] = await sequelize.query(`
      SELECT 
        id,
        logger_id,
        ip_address,
        last_seen,
        created_at
      FROM loggers
      ORDER BY last_seen DESC
    `);
    
    console.log(`\n📊 Found ${loggers.length} loggers:`);
    if (loggers.length === 0) {
      console.log('❌ No ESP32 loggers found! This explains why there are no operational events.');
      console.log('   Events are typically generated by ESP32 devices monitoring asset states.');
    } else {
      loggers.forEach((logger, index) => {
        const lastSeen = logger.last_seen ? new Date(logger.last_seen).toLocaleString() : 'Never';
        console.log(`  ${index + 1}. Logger ${logger.logger_id} (DB ID: ${logger.id})`);
        console.log(`     IP Address: ${logger.ip_address || 'Not set'}`);
        console.log(`     Last Seen: ${lastSeen}`);
        console.log('');
      });
    }
    
    // Check current shift
    const [currentShift] = await sequelize.query(`
      SELECT 
        id,
        shift_name,
        start_time,
        end_time,
        status,
        created_at
      FROM shifts
      WHERE end_time IS NULL OR status = 'active'
      ORDER BY created_at DESC
      LIMIT 1
    `);
    
    if (currentShift.length > 0) {
      const shift = currentShift[0];
      console.log(`\n🔄 Current Active Shift:`);
      console.log(`  Name: ${shift.shift_name}`);
      console.log(`  Started: ${new Date(shift.start_time).toLocaleString()}`);
      console.log(`  Status: ${shift.status}`);
      
      // Check events for this shift
      const [shiftEvents] = await sequelize.query(`
        SELECT COUNT(*) as count, event_type
        FROM events
        WHERE timestamp >= ?
        GROUP BY event_type
        ORDER BY count DESC
      `, {
        replacements: [shift.start_time]
      });
      
      console.log(`\n📊 Events during current shift:`);
      if (shiftEvents.length === 0) {
        console.log('  ❌ No events found for current shift!');
      } else {
        shiftEvents.forEach(event => {
          console.log(`  ${event.event_type}: ${event.count} events`);
        });
      }
    } else {
      console.log('\n❌ No active shift found');
    }
    
    // Analyze event patterns
    console.log('\n📈 Event Generation Analysis:');
    
    const [eventStats] = await sequelize.query(`
      SELECT 
        DATE(timestamp) as date,
        event_type,
        COUNT(*) as count
      FROM events
      GROUP BY DATE(timestamp), event_type
      ORDER BY date DESC, count DESC
    `);
    
    if (eventStats.length === 0) {
      console.log('  ❌ No events found in database');
    } else {
      console.log('  Events by date and type:');
      eventStats.forEach(stat => {
        console.log(`    ${stat.date}: ${stat.event_type} (${stat.count} events)`);
      });
    }
    
    // Check for recent asset state changes
    console.log('\n🔄 Recent Asset State Changes:');
    const [recentStateChanges] = await sequelize.query(`
      SELECT 
        a.name as asset_name,
        a.current_state,
        a.last_state_change
      FROM assets a
      WHERE a.last_state_change IS NOT NULL
      ORDER BY a.last_state_change DESC
    `);
    
    if (recentStateChanges.length === 0) {
      console.log('  ❌ No recent state changes recorded');
    } else {
      recentStateChanges.forEach(change => {
        const changeTime = new Date(change.last_state_change).toLocaleString();
        console.log(`  ${change.asset_name}: ${change.current_state} (${changeTime})`);
      });
    }
    
    // Recommendations
    console.log('\n💡 Recommendations:');
    if (loggers.length === 0) {
      console.log('  1. ❌ No ESP32 loggers detected - this is the main issue!');
      console.log('     - ESP32 devices generate operational events (start/stop/state changes)');
      console.log('     - Without loggers, only manual shift events are created');
      console.log('     - Check ESP32 device connections and registration');
    }
    
    if (assets.length > 0 && loggers.length === 0) {
      console.log('  2. 🔧 Assets exist but no loggers assigned');
      console.log('     - Assets need to be connected to ESP32 loggers to generate events');
      console.log('     - Check asset-logger assignments');
    }
    
    const totalEvents = await sequelize.query(`SELECT COUNT(*) as count FROM events`);
    if (totalEvents[0][0].count < 50) {
      console.log('  3. 📊 Very few events in database');
      console.log('     - Consider generating test data for demonstration');
      console.log('     - Or ensure ESP32 devices are actively monitoring assets');
    }
    
  } catch (error) {
    console.error('❌ Error:', error.message);
    console.error('Stack:', error.stack);
  } finally {
    await sequelize.close();
  }
}

debugEventGeneration();